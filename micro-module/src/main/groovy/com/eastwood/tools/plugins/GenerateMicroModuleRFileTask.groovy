package com.eastwood.tools.plugins

import com.android.build.gradle.api.BaseVariant
import com.eastwood.tools.plugins.core.MicroModule
import com.eastwood.tools.plugins.core.MicroModuleInfo
import com.eastwood.tools.plugins.core.Utils
import org.gradle.api.DefaultTask
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.tasks.TaskAction
import org.objectweb.asm.*

import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.jar.JarOutputStream
import java.util.zip.ZipEntry

class GenerateMicroModuleRFileTask extends DefaultTask {

    public final static List<String> SUPPORT_RESOURCE_TYPE = ["anim", "array", "attr", "bool", "color", "dimen", "mipmap",
                                                              "drawable", "id", "integer", "layout", "menu", "plurals", "string", "style", "styleable"]

    String packageName
    File outputDir
    MicroModuleInfo microModuleInfo

    boolean appliedKotlinPlugin
    BaseVariant variant
    boolean generatedMicroModuleRClass

    @TaskAction
    def run() {
        generatedMicroModuleRClass = true
        if (appliedKotlinPlugin) {
            File symbolFile = getSymbolFile(getProject(), variant)
            if (symbolFile.exists()) {
                List<String> resourceTypeList = getResourceTypeList(symbolFile)
                generateVariantMicroModuleRClass(getProject(), microModuleInfo, packageName, outputDir, true, resourceTypeList)
            } else {
                generateVariantMicroModuleRClass(getProject(), microModuleInfo, packageName, outputDir, true, SUPPORT_RESOURCE_TYPE)
            }
        } else {
            generateVariantMicroModuleRClass(getProject(), microModuleInfo, packageName, outputDir, false, null)
        }
    }

    void revertMicroModuleRClass() {
        generateVariantMicroModuleRClass(getProject(), microModuleInfo, packageName, outputDir, true, SUPPORT_RESOURCE_TYPE)
    }

    private static File getSymbolFile(Project project, BaseVariant variant) {
        File symbolFile = null
        def task = getVariantGenerateRFileTask(project, variant)
        if (task != null) {
            task.outputs.files.each {
                if (it.absolutePath.endsWith("R.txt")) {
                    symbolFile = it
                }
            }
        }
        return symbolFile
    }

    private static Task getVariantGenerateRFileTask(Project project, BaseVariant variant) {
        def taskName = "process${variant.name.capitalize()}Resources"
        def task = project.tasks.findByName(taskName)
        if (task == null) {
            taskName = "generate${variant.name.capitalize()}RFile"
            task = project.tasks.findByName(taskName)
        }
        return task
    }

    private static List<String> getResourceTypeList(File symbolFile) {
        List<String> resourceTypeList = new ArrayList<>()
        String currentType = null
        String resourceTypeTemp
        symbolFile.readLines().each {
            resourceTypeTemp = it.split(" ")[1]
            if (resourceTypeTemp != currentType) {
                currentType = resourceTypeTemp
                resourceTypeList.add(currentType)
            }
        }
        return resourceTypeList
    }

    private static void generateVariantMicroModuleRClass(Project project, MicroModuleInfo microModuleInfo, String packageName, File outputDir, boolean appliedKotlinPlugin, List<String> resourceType) {
        def packageNames = []
        microModuleInfo.includeMicroModules.each {
            MicroModule microModule = it.value
            def microManifestFile = new File(microModule.microModuleDir, MicroModulePlugin.MAIN_MANIFEST_PATH)
            if (!microManifestFile.exists()) {
                return
            }
            def microModulePackageName = Utils.getAndroidManifestPackageName(microManifestFile)
            if (microModulePackageName == null || packageNames.contains(microModulePackageName) || microModulePackageName == packageName) {
                return
            }

            packageNames << microModulePackageName
            def RPath = outputDir.canonicalPath + "/" + microModulePackageName.replace(".", "/")
            File RFile = project.file(RPath + "/R.java")
            project.file(RPath).mkdirs()

            if (appliedKotlinPlugin) {
                def RJava = "package " + microModulePackageName + ";\n\n/** This class is generated by micro-module plugin, DO NOT MODIFY. */\npublic class R extends " + packageName + ".R {\n\n";
                resourceType.each {
                    RJava += "    public static class $it extends $packageName" + ".R." + "$it {}\n"
                }
                RJava += "\n}"
                RFile.setText(RJava)
            } else {
                RFile.setText("package " + microModulePackageName + ";\n\n/** This class is generated by micro-module plugin, DO NOT MODIFY. */\npublic class R extends " + packageName + ".R {\n\n}")
            }
        }
    }

    static void modifyModuleRFile(Project project, BaseVariant variant, String packageName, MicroModuleInfo microModuleInfo, File outputDir, boolean appliedKotlinPlugin) {
        def task = getVariantGenerateRFileTask(project, variant)
        if (task == null) return

        task.doLast {
            File RFile = null
            task.outputs.files.each {
                if (it.isDirectory()) {
                    def RJava = new File(it, packageName.replace(".", "/") + "/R.java")
                    if (RJava.exists()) {
                        RFile = RJava
                    }
                } else if (it.name == "R.jar") {
                    RFile = it
                }
            }

            if (RFile == null) {
                throw new RuntimeException("Can not find R file.")
            }

            modifyRFileAccess(RFile, packageName, appliedKotlinPlugin)

            if (appliedKotlinPlugin) {
                File symbolFile = getSymbolFile(project, variant)
                if (symbolFile.exists()) {
                    List<String> resourceTypeList = getResourceTypeList(symbolFile)
                    generateVariantMicroModuleRClass(project, microModuleInfo, packageName, outputDir, true, resourceTypeList)
                }
            }
        }
    }

    private static void modifyRFileAccess(File RFile, String packageName, boolean appliedKotlinPlugin) {
        if (RFile.name.endsWith('.java')) {
            modifyRJavaAccess(RFile, appliedKotlinPlugin)
        } else {
            modifyRClassAccess(RFile, packageName)
        }
    }

    private static void modifyRJavaAccess(File RFile, boolean appliedKotlinPlugin) {
        if (appliedKotlinPlugin) {
            Map<String, String> resourceType = new HashMap<>()
            def newR = RFile.text.replace(" final class ", " class ").replace("private R() {}", "")
            def resourcesPattern = /static class ([a-z]+) \{/
            def matcher = (newR =~ resourcesPattern)
            while (matcher.find()) {
                resourceType.put(matcher.group(1), null)
            }
            resourceType.keySet().each {
                newR = newR.replace("private $it() {}", "")
            }
            RFile.write(newR)
        } else {
            def newR = RFile.text.replace("public final class R", "public class R").replace("private R() {}", "")
            RFile.write(newR)
        }
    }

    private static void modifyRClassAccess(File RFile, String packageName) {
        String targetRClass = packageName.replace(".", "/") + "/R"
        Map<String, byte[]> tempModifiedClassByteMap = new HashMap()
        JarFile jarFile = new JarFile(RFile)
        Enumeration<JarEntry> jarEntryEnumeration = jarFile.entries()
        while (jarEntryEnumeration.hasMoreElements()) {
            JarEntry jarEntry = jarEntryEnumeration.nextElement()
            String filename = jarEntry.getName()
            if (!filename.startsWith(targetRClass)) {
                continue
            }

            InputStream inputStream = jarFile.getInputStream(jarEntry)
            if (inputStream != null) {
                byte[] bytes = modifyRClassAccess(inputStream.bytes)
                if (bytes != null) {
                    tempModifiedClassByteMap.put(filename, bytes)
                }
            }
            inputStream.close()
        }

        if (tempModifiedClassByteMap.size() != 0) {
            File tempJar = new File(RFile.absolutePath.replace('.jar', 'temp.jar'))
            if (tempJar.exists())
                tempJar.delete()

            jarEntryEnumeration = jarFile.entries()
            JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(tempJar))
            while (jarEntryEnumeration.hasMoreElements()) {
                JarEntry jarEntry = jarEntryEnumeration.nextElement()
                String filename = jarEntry.getName()
                ZipEntry zipEntry = new ZipEntry(filename)
                jarOutputStream.putNextEntry(zipEntry)
                if (tempModifiedClassByteMap.containsKey(filename)) {
                    jarOutputStream.write(tempModifiedClassByteMap.get(filename))
                } else {
                    InputStream inputStream = jarFile.getInputStream(jarEntry)
                    jarOutputStream.write(inputStream.bytes)
                    inputStream.close()
                }
                jarOutputStream.closeEntry()
            }
            jarOutputStream.close()
            jarFile.close()

            FileOutputStream outputStream = new FileOutputStream(RFile)
            outputStream.write(tempJar.bytes)
            outputStream.close()
            tempJar.delete()
        } else {
            jarFile.close()
        }
    }

    private static byte[] modifyRClassAccess(byte[] bytes) {
        ClassWriter classWriter = new ClassWriter(0)
        RClassAdapter targetClassAdapter = new RClassAdapter(Opcodes.ASM5, classWriter)
        ClassReader classReader = new ClassReader(bytes)
        classReader.accept(targetClassAdapter, 0)
        return classWriter.toByteArray()
    }

    private static class RClassAdapter extends ClassVisitor {

        RClassAdapter(int api, ClassVisitor cv) {
            super(api, cv)
        }

        @Override
        void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
            super.visit(version, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, name, signature, superName, interfaces)
        }

        @Override
        MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
            return super.visitMethod(Opcodes.ACC_PUBLIC, name, desc, signature, exceptions)
        }

        @Override
        void visitInnerClass(String name, String outerName, String innerName, int access) {
            super.visitInnerClass(name, outerName, innerName, Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC)
        }
    }

}
