package com.eastwood.tools.plugins

import com.android.build.gradle.api.BaseVariant
import com.eastwood.tools.plugins.core.MicroModule
import com.eastwood.tools.plugins.core.MicroModuleInfo
import com.eastwood.tools.plugins.core.Utils
import org.gradle.api.DefaultTask
import org.gradle.api.Project
import org.gradle.api.tasks.TaskAction
import org.objectweb.asm.*

import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.jar.JarOutputStream
import java.util.zip.ZipEntry

class GenerateMicroModuleRFileTask extends DefaultTask {

    public final static String R_PATH = "/build/generated/source/r/"
    public final static String R_PATH_3_2 = "/build/generated/not_namespaced_r_class_sources/"
    public final static String R_PATH_3_3 = "/build/intermediates/compile_only_not_namespaced_r_class_jar/"

    String packageName
    File outputDir
    MicroModuleInfo microModuleInfo

    @TaskAction
    def run() {
        def packageNames = []
        microModuleInfo.includeMicroModules.each {
            MicroModule microModule = it.value
            def microManifestFile = new File(microModule.microModuleDir, MicroModulePlugin.MAIN_MANIFEST_PATH)
            if (!microManifestFile.exists()) {
                return
            }
            def microModulePackageName = Utils.getAndroidManifestPackageName(microManifestFile)
            if (microModulePackageName == null || packageNames.contains(microModulePackageName) || microModulePackageName == packageName) {
                return
            }

            packageNames << microModulePackageName
            def RPath = outputDir.canonicalPath + "/" + microModulePackageName.replace(".", "/")
            File RFile = project.file(RPath + "/R.java")
            if (RFile.exists()) {
                return
            }
            project.file(RPath).mkdirs()
            RFile.setText("package " + microModulePackageName + ";\n\n/** This class is generated by micro-module plugin, DO NOT MODIFY. */\npublic class R extends " + packageName + ".R {\n\n}")
        }
    }

    static void rewriteOrGenerateMainMicroModuleRFile(Project project, BaseVariant variant, String packageName) {
        def rDir = "r"
        def taskName = "process${variant.name.capitalize()}Resources"
        def task = project.tasks.findByName(taskName)
        if (task == null) {
            rDir = "out"
            taskName = "generate${variant.name.capitalize()}RFile"
            task = project.tasks.findByName(taskName)
        }
        if (task == null) return

        task.doLast {
            def path
            def RFile
            if (new File(project.projectDir, R_PATH).exists()) {
                path = project.projectDir.absolutePath + R_PATH + variant.name + "/"
                RFile = project.file(path + packageName.replace(".", "/") + "/R.java")
            } else if (new File(project.projectDir, R_PATH_3_2).exists()) {
                path = project.projectDir.absolutePath + R_PATH_3_2 + variant.name + "/" + taskName + "/" + rDir + "/"
                RFile = project.file(path + packageName.replace(".", "/") + "/R.java")
            } else if (new File(project.projectDir, R_PATH_3_3).exists()) {
                path = project.projectDir.absolutePath + R_PATH_3_3 + variant.name + "/" + taskName + "/"
                RFile = project.file(path + "/R.jar")
            } else {
                throw new RuntimeException("Can not find R file.")
            }
            modifyRClassAccess(RFile, packageName)
        }
    }

    private static void modifyRClassAccess(File RFile, String packageName) {
        if (RFile.name.endsWith('.java')) {
            def newR = RFile.text.replace("public final class R", "public class R").replace("private R() {}", "")
            RFile.write(newR)
            return
        }

        String targetRClass = packageName.replace(".", "/") + "/R.class"
        Map<String, byte[]> tempModifiedClassByteMap = new HashMap()
        JarFile jarFile = new JarFile(RFile)
        Enumeration<JarEntry> jarEntryEnumeration = jarFile.entries()
        while (jarEntryEnumeration.hasMoreElements()) {
            JarEntry jarEntry = jarEntryEnumeration.nextElement()
            String filename = jarEntry.getName()
            if (filename != targetRClass) {
                continue
            }

            InputStream inputStream = jarFile.getInputStream(jarEntry)
            if (inputStream != null) {
                byte[] bytes = modifyRClassAccess(inputStream.bytes)
                if (bytes != null) {
                    tempModifiedClassByteMap.put(filename, bytes)
                }
            }
            inputStream.close()
        }

        if (tempModifiedClassByteMap.size() != 0) {
            File tempJar = new File(RFile.absolutePath.replace('.jar', 'temp.jar'))
            if (tempJar.exists())
                tempJar.delete()

            jarEntryEnumeration = jarFile.entries()
            JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(tempJar))
            while (jarEntryEnumeration.hasMoreElements()) {
                JarEntry jarEntry = jarEntryEnumeration.nextElement()
                String filename = jarEntry.getName()
                ZipEntry zipEntry = new ZipEntry(filename)
                jarOutputStream.putNextEntry(zipEntry)
                if (tempModifiedClassByteMap.containsKey(filename)) {
                    jarOutputStream.write(tempModifiedClassByteMap.get(filename))
                } else {
                    InputStream inputStream = jarFile.getInputStream(jarEntry)
                    jarOutputStream.write(inputStream.bytes)
                    inputStream.close()
                }
                jarOutputStream.closeEntry()
            }
            jarOutputStream.close()
            jarFile.close()

            FileOutputStream outputStream = new FileOutputStream(RFile)
            outputStream.write(tempJar.bytes)
            outputStream.close()
            tempJar.delete()
        } else {
            jarFile.close()
        }
    }

    private static byte[] modifyRClassAccess(byte[] bytes) {
        ClassWriter classWriter = new ClassWriter(0)
        RClassAdapter targetClassAdapter = new RClassAdapter(Opcodes.ASM5, classWriter)
        ClassReader classReader = new ClassReader(bytes)
        classReader.accept(targetClassAdapter, 0)
        return classWriter.toByteArray()
    }

    private static class RClassAdapter extends ClassVisitor {

        RClassAdapter(int api, ClassVisitor cv) {
            super(api, cv)
        }

        @Override
        void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
            super.visit(version, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, name, signature, superName, interfaces)
        }

        @Override
        MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
            return super.visitMethod(Opcodes.ACC_PUBLIC, name, desc, signature, exceptions)
        }
    }

}
